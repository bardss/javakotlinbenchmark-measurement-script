/*
 * The Computer Language Benchmarks Game
 * https://salsa.debian.org/benchmarksgame-team/benchmarksgame/
 * 
 * modified by Mehmet D. AKIN
 * modified by Daryl Griffith
 */
package javabenchmarks.fasta;

import java.io.IOException;
import java.io.OutputStream;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.atomic.AtomicInteger;

public class Fasta {

    static final int LINE_LENGTH = 60;
    static final int LINE_COUNT = 1024;
    static final NucleotideSelector[] WORKERS
            = new NucleotideSelector[
            Runtime.getRuntime().availableProcessors() &gt; 1
                    ? Runtime.getRuntime().availableProcessors() - 1
                    : 1];
    static final AtomicInteger IN = new AtomicInteger();
    static final AtomicInteger OUT = new AtomicInteger();
    static final int BUFFERS_IN_PLAY = 6;
    static final int IM = 139968;
    static final int IA = 3877;
    static final int IC = 29573;
    static final float ONE_OVER_IM = 1f / IM;
    static int last = 42;

    public static void execute(String[] args) {
        int n = 1000;

        if (args.length &gt; 0) {
            n = Integer.parseInt(args[0]);
        }
        for (int i = 0; i &lt; WORKERS.length; i++) {
            WORKERS[i] = new NucleotideSelector();
            WORKERS[i].setDaemon(true);
            WORKERS[i].start();
        }
        try (OutputStream writer = System.out;) {
            final int bufferSize = LINE_COUNT * LINE_LENGTH;

            for (int i = 0; i &lt; BUFFERS_IN_PLAY; i++) {
                lineFillALU(
                        new AluBuffer(LINE_LENGTH, bufferSize, i * bufferSize));
            }
            speciesFillALU(writer, n * 2, &quot;&gt;ONE Homo sapiens alu\n&quot;);
            for (int i = 0; i &lt; BUFFERS_IN_PLAY; i++) {
                writeBuffer(writer);
                lineFillRandom(new Buffer(true, LINE_LENGTH, bufferSize));
            }
            speciesFillRandom(writer
                    , n * 3
                    , &quot;&gt;TWO IUB ambiguity codes\n&quot;
                    , true);
            for (int i = 0; i &lt; BUFFERS_IN_PLAY; i++) {
                writeBuffer(writer);
                lineFillRandom(new Buffer(false, LINE_LENGTH, bufferSize));
            }
            speciesFillRandom(writer
                    , n * 5
                    , &quot;&gt;THREE Homo sapiens frequency\n&quot;
                    , false);
            for (int i = 0; i &lt; BUFFERS_IN_PLAY; i++) {
                writeBuffer(writer);
            }
        } catch (IOException ex) {
        }
    }

    private static void lineFillALU(AbstractBuffer buffer) {
        WORKERS[OUT.incrementAndGet() % WORKERS.length].put(buffer);
    }

    private static void bufferFillALU(OutputStream writer
            , int buffers) throws IOException {
        AbstractBuffer buffer;

        for (int i = 0; i &lt; buffers; i++) {
            buffer = WORKERS[IN.incrementAndGet() % WORKERS.length].take();
            writer.write(buffer.nucleotides);
            lineFillALU(buffer);
        }
    }

    private static void speciesFillALU(final OutputStream writer
            , final int nChars
            , final String name) throws IOException {
        final int bufferSize = LINE_COUNT * LINE_LENGTH;
        final int bufferCount = nChars / bufferSize;
        final int bufferLoops = bufferCount - BUFFERS_IN_PLAY;
        final int charsLeftover = nChars - (bufferCount * bufferSize);

        writer.write(name.getBytes());
        bufferFillALU(writer, bufferLoops);
        if (charsLeftover &gt; 0) {
            writeBuffer(writer);
            lineFillALU(
                    new AluBuffer(LINE_LENGTH
                            , charsLeftover
                            , nChars - charsLeftover));
        }
    }

    private static void lineFillRandom(Buffer buffer) {
        for (int i = 0; i &lt; buffer.randoms.length; i++) {
            last = (last * IA + IC) % IM;
            buffer.randoms[i] = last * ONE_OVER_IM;
        }
        WORKERS[OUT.incrementAndGet() % WORKERS.length].put(buffer);
    }

    private static void bufferFillRandom(OutputStream writer
            , int loops) throws IOException {
        AbstractBuffer buffer;

        for (int i = 0; i &lt; loops; i++) {
            buffer = WORKERS[IN.incrementAndGet() % WORKERS.length].take();
            writer.write(buffer.nucleotides);
            lineFillRandom((Buffer) buffer);
        }
    }

    private static void speciesFillRandom(final OutputStream writer
            , final int nChars
            , final String name
            , final boolean isIUB) throws IOException {
        final int bufferSize = LINE_COUNT * LINE_LENGTH;
        final int bufferCount = nChars / bufferSize;
        final int bufferLoops = bufferCount - BUFFERS_IN_PLAY;
        final int charsLeftover = nChars - (bufferCount * bufferSize);

        writer.write(name.getBytes());
        bufferFillRandom(writer, bufferLoops);
        if (charsLeftover &gt; 0) {
            writeBuffer(writer);
            lineFillRandom(new Buffer(isIUB, LINE_LENGTH, charsLeftover));
        }
    }

    private static void writeBuffer(OutputStream writer) throws IOException {
        writer.write(
                WORKERS[IN.incrementAndGet() % WORKERS.length]
                        .take()
                        .nucleotides);
    }

    public static class NucleotideSelector extends Thread {

        private final BlockingQueue&lt;AbstractBuffer&gt;
                in = new ArrayBlockingQueue&lt;&gt;(BUFFERS_IN_PLAY);
        private final BlockingQueue&lt;AbstractBuffer&gt;
                out = new ArrayBlockingQueue&lt;&gt;(BUFFERS_IN_PLAY);

        public void put(AbstractBuffer line) {
            try {
                in.put(line);
            } catch (InterruptedException ex) {
            }
        }

        &#64;Override
        public void run() {
            AbstractBuffer line;

            try {
                for (;;) {
                    line = in.take();
                    line.selectNucleotides();
                    out.put(line);
                }
            } catch (InterruptedException ex) {
            }
        }

        public AbstractBuffer take() {
            try {
                return out.take();
            } catch (InterruptedException ex) {
            }
            return null;
        }
    }

    public abstract static class AbstractBuffer {

        final int LINE_LENGTH;
        final int LINE_COUNT;
        byte[] chars;
        final byte[] nucleotides;
        final int CHARS_LEFTOVER;

        public AbstractBuffer(final int lineLength, final int nChars) {
            LINE_LENGTH = lineLength;
            final int outputLineLength = lineLength + 1;
            LINE_COUNT = nChars / lineLength;
            CHARS_LEFTOVER = nChars % lineLength;
            final int nucleotidesSize
                    = nChars + LINE_COUNT + (CHARS_LEFTOVER == 0 ? 0 : 1);
            final int lastNucleotide = nucleotidesSize - 1;

            nucleotides = new byte[nucleotidesSize];
            for (int i = lineLength
                 ; i &lt; lastNucleotide
                    ; i += outputLineLength) {
                nucleotides[i] = &apos;\n&apos;;
            }
            nucleotides[nucleotides.length - 1] = &apos;\n&apos;;
        }

        public abstract void selectNucleotides();
    }

    public static class AluBuffer extends AbstractBuffer {

        final String ALU =
                &quot;GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG&quot;
                        + &quot;GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA&quot;
                        + &quot;CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT&quot;
                        + &quot;ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA&quot;
                        + &quot;GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG&quot;
                        + &quot;AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC&quot;
                        + &quot;AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA&quot;;
        final int MAX_ALU_INDEX = ALU.length() - LINE_LENGTH;
        final int ALU_ADJUST = LINE_LENGTH - ALU.length();
        final int nChars;
        int charIndex;
        int nucleotideIndex;

        public AluBuffer(final int lineLength
                , final int nChars
                , final int offset) {
            super(lineLength, nChars);
            this.nChars = nChars;
            chars = (ALU + ALU.substring(0, LINE_LENGTH)).getBytes();
            charIndex = offset % ALU.length();
        }

        &#64;Override
        public void selectNucleotides() {
            nucleotideIndex = 0;
            for (int i = 0; i &lt; LINE_COUNT; i++) {
                ALUFillLine(LINE_LENGTH);
            }
            if (CHARS_LEFTOVER &gt; 0) {
                ALUFillLine(CHARS_LEFTOVER);
            }
            charIndex = (charIndex + (nChars * (BUFFERS_IN_PLAY - 1)))
                    % ALU.length();
        }

        private void ALUFillLine(final int charCount) {
            System.arraycopy(chars
                    , charIndex
                    , nucleotides
                    , nucleotideIndex
                    , charCount);
            charIndex += charIndex &lt; MAX_ALU_INDEX ? charCount : ALU_ADJUST;
            nucleotideIndex += charCount + 1;
        }
    }

    public static class Buffer extends AbstractBuffer {

        final byte[] iubChars = new byte[]{
                &apos;a&apos;, &apos;c&apos;, &apos;g&apos;, &apos;t&apos;,
                &apos;B&apos;, &apos;D&apos;, &apos;H&apos;, &apos;K&apos;,
                &apos;M&apos;, &apos;N&apos;, &apos;R&apos;, &apos;S&apos;,
                &apos;V&apos;, &apos;W&apos;, &apos;Y&apos;};
        final double[] iubProbs = new double[]{
                0.27, 0.12, 0.12, 0.27,
                0.02, 0.02, 0.02, 0.02,
                0.02, 0.02, 0.02, 0.02,
                0.02, 0.02, 0.02,};
        final byte[] sapienChars = new byte[]{
                &apos;a&apos;,
                &apos;c&apos;,
                &apos;g&apos;,
                &apos;t&apos;};
        final double[] sapienProbs = new double[]{
                0.3029549426680,
                0.1979883004921,
                0.1975473066391,
                0.3015094502008};
        final float[] probs;
        final float[] randoms;
        final int charsInFullLines;

        public Buffer(final boolean isIUB
                , final int lineLength
                , final int nChars) {
            super(lineLength, nChars);
            double cp = 0;
            final double[] dblProbs = isIUB ? iubProbs : sapienProbs;

            chars = isIUB ? iubChars : sapienChars;
            probs = new float[dblProbs.length];
            for (int i = 0; i &lt; probs.length; i++) {
                cp += dblProbs[i];
                probs[i] = (float) cp;
            }
            probs[probs.length - 1] = 2f;
            randoms = new float[nChars];
            charsInFullLines = (nChars / lineLength) * lineLength;
        }

        &#64;Override
        public void selectNucleotides() {
            int i, j, m;
            float r;
            int k;

            for (i = 0, j = 0; i &lt; charsInFullLines; j++) {
                for (k = 0; k &lt; LINE_LENGTH; k++) {
                    r = randoms[i++];
                    for (m = 0; probs[m] &lt; r; m++) {
                    }
                    nucleotides[j++] = chars[m];
                }
            }
            for (k = 0; k &lt; CHARS_LEFTOVER; k++) {
                r = randoms[i++];
                for (m = 0; probs[m] &lt; r; m++) {
                }
                nucleotides[j++] = chars[m];
            }
        }
    }
}
